import { useState as T, useEffect as f } from "react";
import { compareObjects as u } from "../utilities/object.es.js";
const F = (o) => {
  const s = o.getBlockId(), [r, d] = T({}), [i, k] = T(null), p = (e) => {
    e.blockId === s && !u(e.blockTemplates, e.prevBlockTemplates) && d(e.blockTemplates);
  }, a = (e) => {
    let t;
    e instanceof Error ? t = e.message : typeof e == "string" ? t = e : t = String(e), k(t);
  };
  f(() => {
    let e = !0;
    return s && ((async () => {
      try {
        const l = await o.getBlockTemplates();
        e && d(l);
      } catch (l) {
        a(l);
      }
    })(), window.emitter.on("AppBridge:BlockTemplatesUpdated", p)), () => {
      e = !1, window.emitter.off("AppBridge:BlockTemplatesUpdated", p);
    };
  }, [o]);
  const c = async () => {
    let e;
    try {
      e = await o.getBlockTemplates();
    } catch (t) {
      a(t);
    }
    e && window.emitter.emit("AppBridge:BlockTemplatesUpdated", {
      blockId: s,
      blockTemplates: e,
      prevBlockTemplates: { ...r }
    });
  };
  return {
    blockTemplates: r,
    addTemplateIdsToKey: async (e, t) => {
      try {
        await o.addTemplateIdsToBlockTemplateKey(e, t);
      } catch (l) {
        a(l);
      }
      c();
    },
    deleteTemplateIdsFromKey: async (e, t) => {
      try {
        await o.deleteTemplateIdsFromBlockTemplateKey(e, t);
      } catch (l) {
        a(l);
      }
      c();
    },
    updateTemplateIdsFromKey: async (e, t) => {
      var n;
      const y = ((n = (await o.getBlockTemplates())[e]) == null ? void 0 : n.map((m) => m.id)) ?? [];
      try {
        await o.deleteTemplateIdsFromBlockTemplateKey(e, y), await o.addTemplateIdsToBlockTemplateKey(e, t);
      } catch (m) {
        a(m);
      }
      c();
    },
    error: i
  };
};
export {
  F as useBlockTemplates
};
//# sourceMappingURL=useBlockTemplates.es.js.map
