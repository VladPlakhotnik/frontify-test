import { SUBSCRIBE_TIMEOUT as i } from "./subscribe.es.js";
import { generateRandomString as n } from "./hash.es.js";
import { TimeoutReachedError as m } from "../errors/TimeoutReachedError.es.js";
import { InitializationError as p } from "../errors/InitializationError.es.js";
class d {
  constructor(s) {
    this.port = s, this.messageBucket = [], this.port.onmessage = (t) => {
      const { token: o } = t.data, e = this.messageBucket.findIndex((r) => r.token === o);
      e > -1 && this.messageBucket.splice(e, 1)[0].resolve(t.data.message);
    };
  }
  post(s) {
    return new Promise((t, o) => {
      const e = n();
      this.messageBucket.push({ message: s, resolve: t, token: e }), this.port.postMessage({ message: s, token: e }), setTimeout(() => {
        o(new m("operation"));
      }, i * 10);
    });
  }
}
class B {
  post() {
    throw new p('First use await platformApp.dispatch({ name: "openConnection" })');
  }
}
export {
  B as ErrorMessageBus,
  d as MessageBus
};
//# sourceMappingURL=MessageBus.es.js.map
