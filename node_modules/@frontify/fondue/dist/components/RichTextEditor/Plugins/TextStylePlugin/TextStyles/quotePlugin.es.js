var i = Object.defineProperty;
var a = (t, e, o) => e in t ? i(t, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : t[e] = o;
var m = (t, e, o) => (a(t, typeof e != "symbol" ? e + "" : e, o), o);
import { jsx as n } from "react/jsx-runtime";
import { createPluginFactory as p } from "@udecode/plate";
import { alignmentClassnames as c } from "../../helper.es.js";
import { merge as g } from "../../../../../utilities/merge.es.js";
import { TextStyles as u } from "../types.es.js";
import { Plugin as f } from "../../Plugin.es.js";
import { defaultStyles as y } from "../../../utils/defaultStyles.es.js";
import { MarkupElement as k } from "../../MarkupElement.es.js";
import { getColumnBreakClasses as d } from "../../ColumnBreakPlugin/utils/getColumnBreakClasses.es.js";
const q = "textstyle-quote-plugin";
class T extends f {
  constructor({ styles: o = y.quote, ...r } = {}) {
    super(u.quote, {
      label: "Quote",
      markupElement: new x(),
      ...r
    });
    m(this, "styles", {});
    this.styles = o;
  }
  plugins() {
    return [E(this.styles)];
  }
}
class x extends k {
  constructor(e = q, o = s) {
    super(e, o);
  }
}
const s = ({ element: t, attributes: e, children: o, styles: r }) => {
  const l = t.align;
  return /* @__PURE__ */ n(
    "blockquote",
    {
      ...e,
      className: g([l && c[l], d(t)]),
      style: r,
      children: o
    }
  );
}, E = (t) => p({
  key: u.quote,
  isElement: !0,
  component: s,
  deserializeHtml: {
    rules: [{ validNodeName: ["blockquote", "BLOCKQUOTE"] }]
  }
})({
  component: (e) => /* @__PURE__ */ n(s, { ...e, styles: t })
});
export {
  s as QuoteMarkupElementNode,
  T as QuotePlugin,
  E as createQuotePlugin
};
//# sourceMappingURL=quotePlugin.es.js.map
