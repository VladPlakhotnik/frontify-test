import { getLicElementClassNames as u } from "../../Plugins/ListPlugin/ListItemContentMarkupElement.es.js";
import { LI_CLASSNAMES as f, getLiStyles as h } from "../../Plugins/ListPlugin/ListItemMarkupElement.es.js";
import { isText as L, ELEMENT_UL as N, ELEMENT_OL as p, ELEMENT_LI as T, ELEMENT_LIC as d, ELEMENT_LINK as g, ELEMENT_MENTION as $ } from "@udecode/plate";
import { merge as C } from "../../../../utilities/merge.es.js";
import { buttonNode as M } from "../nodes/button.es.js";
import { checkItemNode as y } from "../nodes/checkItem.es.js";
import { linkNode as _ } from "../nodes/link.es.js";
import { mentionHtmlNode as S } from "../nodes/mentionHtmlNode.es.js";
import { reactCssPropsToCss as n } from "./reactCssPropsToCss.es.js";
import { serializeLeafToHtml as k } from "./serializeLeafToHtml.es.js";
import { UL_CLASSES as x } from "../../Plugins/ListPlugin/UnorderedListPlugin/UnorderedListMarkupElement.es.js";
import { getOrderedListClasses as I, OL_STYLES as b } from "../../Plugins/ListPlugin/OrderedListPlugin/OrderedListMarkupElement.es.js";
import { ELEMENT_BUTTON as H, alignmentClassnames as v } from "../../Plugins/helper.es.js";
import { TextStyles as r } from "../../Plugins/TextStylePlugin/types.es.js";
import { ELEMENT_CHECK_ITEM as w } from "../../Plugins/CheckboxListPlugin/id.es.js";
const c = (t, e) => {
  let o = 0;
  for (const s of t) {
    let i = 0;
    s.type === e && (i = 1), s.children && (i += c(s.children, e)), o = Math.max(o, i);
  }
  return o;
}, O = (t, e, { mappedMentionable: o, nestingCount: s = {} }) => {
  if (L(t))
    return k(t);
  const i = s[t.type] || c([t], t.type);
  let a = "";
  for (const l of t.children)
    a += O(l, e, {
      nestingCount: {
        ...s,
        [l.type]: i
      },
      mappedMentionable: o
    });
  const E = A[t.type];
  try {
    return E({
      classNames: U(
        t.breakAfterColumn,
        t.align
      ),
      children: a,
      rootNestingCount: i,
      node: t,
      mappedMentionable: o,
      styles: e
    }) ?? a;
  } catch {
    return console.warn(`The htmlMapper for node type: '${t.type}' does not exist.`), a;
  }
}, A = {
  [r.heading1]: (t) => m(r.heading1, t, "h1"),
  [r.heading2]: (t) => m(r.heading2, t, "h2"),
  [r.heading3]: (t) => m(r.heading3, t, "h3"),
  [r.heading4]: (t) => m(r.heading4, t, "h4"),
  [r.p]: (t) => m(r.p, t, "p"),
  [r.custom1]: (t) => m(r.custom1, t, "p"),
  [r.custom2]: (t) => m(r.custom2, t, "p"),
  [r.custom3]: (t) => m(r.custom3, t, "p"),
  [r.quote]: (t) => m(r.quote, t, "p"),
  [r.imageTitle]: (t) => m(r.imageTitle, t, "p"),
  [r.imageCaption]: (t) => m(r.imageCaption, t, "p"),
  [N]: (t) => `<ul dir="auto" class="${x} ${t.classNames}">${t.children}</ul>`,
  [p]: ({ classNames: t, children: e, node: o, rootNestingCount: s }) => {
    const i = Math.max(s - c([o], p), 0);
    return `<ol dir="auto" class="${I(i)} ${t}" style="${n(
      b
    )}">${e}</ol>`;
  },
  [T]: ({ classNames: t, children: e, node: o, styles: s }) => `<li dir="auto" class="${t} ${f}" style="${n(
    h(o, s)
  )}">${e}</li>`,
  [d]: ({ classNames: t, children: e, node: o }) => `<p dir="auto" class="${t} ${u(o)}"><span>${e}</span></p>`,
  [g]: ({ node: t, children: e, classNames: o, styles: s }) => _(t, e, o, s),
  [H]: ({ node: t, children: e, classNames: o, styles: s }) => M(t, e, o, s),
  [w]: ({ node: t, children: e, classNames: o, styles: s }) => y(t, e, o, s),
  [$]: ({ node: t, mappedMentionable: e }) => S(t, { mentionable: e })
}, m = (t, { classNames: e, styles: o, children: s }, i) => `<${i} dir="auto" class="${e}" style="${n(o[t])}">${s}</${i}>`, U = (t, e) => {
  const o = "tw-break-words", s = t === "active" ? "tw-break-after-column tw-break-inside-avoid-column" : "", i = e ? v[e] : "";
  return C([i, o, s]);
};
export {
  O as serializeNodeToHtmlRecursive
};
//# sourceMappingURL=serializeNodeToHtmlRecursive.es.js.map
