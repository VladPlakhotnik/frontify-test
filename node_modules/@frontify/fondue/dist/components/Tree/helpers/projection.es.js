import { arrayMove as W } from "@dnd-kit/sortable";
import { ROOT_ID as _, INDENTATION_WIDTH as A } from "./constants.es.js";
const I = (t) => t ? t.props.level : 0, E = (t) => Math.round(t / A), H = (t) => ((t == null ? void 0 : t.props.levelConstraint) ?? null) !== null ? t.props.levelConstraint : !1, R = (t, i) => {
  const r = I(t);
  if (t != null && t.props.accepts) {
    const u = I(i);
    return r >= u ? r + 1 : u;
  } else
    return r;
}, b = (t, i) => {
  const r = I(i);
  return t != null && t.props.accepts ? r : Math.min(I(t), r);
}, z = ({ nodes: t, activeId: i, overId: r, dragOffset: u }) => {
  var w;
  const o = t.findIndex(({ props: n }) => n.id === r), a = t.findIndex(({ props: n }) => n.id === i), h = t[a], D = W(t, a, o), e = D[o - 1], d = D[o + 1], g = H(h), C = E(u), N = (((w = h == null ? void 0 : h.props) == null ? void 0 : w.level) ?? 0) + C, m = g !== !1 ? g : R(e, d), v = g !== !1 ? g : b(e, d);
  let c = N || I(d);
  N >= m ? c = m : N < v && (c = v);
  const y = () => {
    var l;
    return c === 0 || !e ? _ : e.props.parentId && c === e.props.level ? e.props.parentId ?? null : e.props.level !== void 0 && c > e.props.level ? e.props.accepts ? e.props.id : e.props.parentId ?? e.props.id : ((l = D.slice(0, o).reverse().find((f) => f.props.level === c)) == null ? void 0 : l.props.parentId) ?? null;
  }, O = (n) => {
    var l;
    return n ? (l = t.find(({ props: f }) => f.id === n)) == null ? void 0 : l.props : null;
  }, x = y(), s = O(x), j = a < o && h.props.parentId !== x ? 1 : 0, P = D.filter(({ props: n }) => n.parentId === x);
  let p = P.findIndex(({ props: n }) => n.id === i);
  if (p < 0) {
    const n = P.findIndex(({ props: l }) => l.id === r);
    if (n >= 0)
      p = n;
    else if (x === r)
      p = -1;
    else if (C < 0) {
      const f = (d.props.parentId ? D.filter(({ props: M }) => M.parentId === d.props.parentId) : []).findIndex(({ props: M }) => M.id === d.props.id);
      f >= 0 ? p = f + (a < o ? -1 : 0) : p = a < o ? P.length : -1;
    } else
      a >= o && (p = P.length);
  }
  p = p + j;
  const T = (s == null ? void 0 : s.level) ?? 0;
  return {
    depth: c,
    maxDepth: m,
    minDepth: v,
    parentId: x ?? null,
    type: s == null ? void 0 : s.type,
    accepts: s == null ? void 0 : s.accepts,
    position: p >= 0 ? p : 0,
    isWithinParent: T ? c > T : !1,
    previousNode: e ? {
      id: e.props.id,
      depth: I(e),
      accepts: e.props.accepts
    } : null
  };
};
export {
  z as getProjection
};
//# sourceMappingURL=projection.es.js.map
