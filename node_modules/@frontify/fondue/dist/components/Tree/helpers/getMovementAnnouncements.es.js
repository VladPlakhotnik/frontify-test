import { isValidElement as D } from "react";
import { arrayMove as E } from "@dnd-kit/sortable";
const h = (o, a, l) => {
  const i = (e) => {
    var p;
    let n = e.id;
    const t = o.nodes.find((r) => r.props.id === e.id);
    return t && D(t.props.contentComponent) ? n = t.props.contentComponent.props.title : (p = t == null ? void 0 : t.props) != null && p.label && (n = t.props.label), n;
  }, s = (e) => {
    var p;
    let n = e == null ? void 0 : e.id;
    const t = o.nodes.find((r) => r.props.id === (e == null ? void 0 : e.id));
    return t && D(t.props.contentComponent) ? n = t.props.contentComponent.props.title : (p = t == null ? void 0 : t.props) != null && p.label && (n = t.props.label), n;
  };
  return {
    onDragStart({ active: e }) {
      return `Picked up ${i(e) || e.id}.`;
    },
    onDragMove({ active: e, over: n }) {
      return g({
        eventName: "onDragMove",
        activeId: e.id,
        activeTitle: i(e),
        overId: n == null ? void 0 : n.id,
        overTitle: s(n),
        treeState: o,
        setCurrentPosition: l,
        currentPosition: a
      });
    },
    onDragOver({ active: e, over: n }) {
      return g({
        eventName: "onDragOver",
        activeId: e.id,
        activeTitle: i(e),
        overId: n == null ? void 0 : n.id,
        overTitle: s(n),
        treeState: o,
        setCurrentPosition: l,
        currentPosition: a
      });
    },
    onDragEnd({ active: e, over: n }) {
      return g({
        eventName: "onDragEnd",
        activeId: e.id,
        activeTitle: i(e),
        overId: n == null ? void 0 : n.id,
        overTitle: s(n),
        treeState: o,
        setCurrentPosition: l,
        currentPosition: a
      });
    },
    onDragCancel({ active: e }) {
      return `Moving was cancelled. ${i(e)} was dropped in its original position.`;
    }
  };
}, g = ({
  eventName: o,
  activeId: a,
  activeTitle: l,
  overId: i,
  overTitle: s,
  treeState: e,
  currentPosition: n,
  setCurrentPosition: t
}) => {
  const p = e.projection;
  if (i && p) {
    if (o !== "onDragEnd") {
      if (n && p.parentId === n.parentId && i === n.overId)
        return;
      t({
        parentId: p.parentId,
        overId: i
      });
    }
    const r = e.nodes.map(({ props: d }) => ({
      id: d.id,
      level: d.level ?? 0,
      parentId: d.parentId
    })), f = r.findIndex(({ id: d }) => d === i), $ = r.findIndex(({ id: d }) => d === a), I = E(r, $, f), c = I[f - 1];
    let m;
    const u = o === "onDragEnd" ? "dropped" : "moved", b = o === "onDragEnd" ? "dropped" : "nested";
    if (c)
      if (p.depth > c.level)
        m = `${l} was ${b} under ${s || c.id}.`;
      else {
        let d = c;
        for (; d && p.depth < d.level; ) {
          const w = d.parentId;
          d = I.find(({ id: x }) => x === w);
        }
        d && (m = `${l} was ${u} after ${s || d.id}.`);
      }
    else {
      const d = I[f + 1];
      m = `${l} was ${u} before ${s || d.id}.`;
    }
    return m;
  }
};
export {
  h as getAnnouncements
};
//# sourceMappingURL=getMovementAnnouncements.es.js.map
