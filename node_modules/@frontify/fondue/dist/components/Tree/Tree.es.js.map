{"version":3,"file":"Tree.es.js","sources":["../../../src/components/Tree/Tree.tsx"],"sourcesContent":["/* (c) Copyright Frontify Ltd., all rights reserved. */\n\nimport {\n    KeyboardEvent,\n    cloneElement,\n    memo,\n    useCallback,\n    useEffect,\n    useMemo,\n    useReducer,\n    useRef,\n    useState,\n    useTransition,\n} from 'react';\nimport { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';\nimport { restrictToWindowEdges } from '@dnd-kit/modifiers';\nimport { enableMapSet, produce } from 'immer';\nimport { createPortal } from 'react-dom';\nimport isEqual from 'lodash-es/isEqual';\nimport {\n    DndContext,\n    DragEndEvent,\n    DragMoveEvent,\n    DragOverlay,\n    KeyboardSensor,\n    MeasuringConfiguration,\n    MeasuringStrategy,\n    PointerSensor,\n    closestCorners,\n    useSensor,\n    useSensors,\n} from '@dnd-kit/core';\n\nimport type {\n    RegisterNodeChildrenPayload,\n    SensorContext,\n    TreeAnnouncements,\n    TreeDragOverEvent,\n    TreeDragStartEvent,\n    TreeItemProps,\n    TreeItemStyling,\n    TreeProps,\n    TreeState,\n    TreeStateAction,\n} from '@components/Tree/types';\n\nimport { type Overlay, TreeItemOverlay } from './TreeItem';\n\nimport {\n    recursivelyRemoveFragmentsAndEnrichChildren,\n    sortableTreeKeyboardCoordinates,\n    useDeepCompareEffect,\n} from './utils';\n\nimport {\n    currentNodesChanged,\n    findIndexById,\n    getAnnouncements,\n    getCurrentChildrenForNewNodesIfExpanded,\n    getNodeChildrenIds,\n    getNodesToRender,\n    getProjection,\n    getReactNodeIdsInFlatArray,\n    handleKeyDownEvent,\n    removeReactNodesFromFlatArray,\n    sensorsActivationConstraint,\n    shouldUpdateTreeState,\n    updateNodeWithNewChildren,\n} from './helpers';\n\nimport { TreeContext, TreeContextProps } from './TreeContext';\nimport { ROOT_ID } from './helpers';\n\nconst measuring: MeasuringConfiguration = {\n    droppable: {\n        strategy: MeasuringStrategy.Always,\n    },\n};\n\nenableMapSet();\n\nconst reducer = produce((draft: TreeState, action: TreeStateAction) => {\n    switch (action.type) {\n        case 'EXPAND_NODE':\n            draft.expandedIds = new Set(draft.expandedIds).add(action.payload);\n            return;\n\n        case 'SHRINK_NODE':\n            const newExpanded = new Set(draft.expandedIds);\n            newExpanded.delete(action.payload);\n\n            draft.expandedIds = newExpanded;\n            return;\n\n        case 'SET_SELECTION_MODE':\n            draft.selectionMode = action.payload.selectionMode;\n            return;\n\n        case 'SET_PROJECTION':\n            if (!isEqual(draft.projection, action.payload)) {\n                draft.projection = action.payload;\n            }\n            return;\n\n        case 'REGISTER_OVERLAY_ITEM':\n            draft.overlay = action.payload;\n            return;\n\n        case 'REGISTER_ROOT_NODES':\n            // reset rootNodes keeping any children when expanded\n            draft.rootNodes = getCurrentChildrenForNewNodesIfExpanded(\n                draft.rootNodes,\n                draft.expandedIds,\n                action.payload,\n            );\n            return;\n\n        case 'REGISTER_NODE_CHILDREN':\n            const { id: parentId, children } = action.payload;\n\n            if (findIndexById(draft.rootNodes, parentId) === -1) {\n                // This can happen when this action is triggered before the rootNodes array is updated\n                // It happens if using static data will all nodes and handling expandedIds outside the Tree component\n                // Most of the cases, it will register the children properly afterwards\n                // See Scrollable Tree With Label story\n                console.warn(`Parent element with ID \"${parentId}\" not found when registering children.`);\n                return;\n            }\n\n            const currentChildrenIds = getNodeChildrenIds(draft.rootNodes, parentId);\n            const newChildrenIds = children.map((node) => node.props.id);\n\n            if (\n                !isEqual(currentChildrenIds, newChildrenIds) ||\n                currentNodesChanged(currentChildrenIds, draft.rootNodes, children)\n            ) {\n                // keep any children when parent expanded\n                const newChildren = getCurrentChildrenForNewNodesIfExpanded(\n                    draft.rootNodes,\n                    draft.expandedIds,\n                    children,\n                );\n                draft.rootNodes = updateNodeWithNewChildren(draft.rootNodes, parentId, newChildren);\n            }\n\n            return;\n\n        case 'UNREGISTER_NODE_CHILDREN':\n            const nodeIds = getReactNodeIdsInFlatArray(draft.rootNodes, action.payload);\n            if (nodeIds.length > 0) {\n                draft.rootNodes = removeReactNodesFromFlatArray(draft.rootNodes, nodeIds);\n            }\n            return;\n\n        case 'REGISTER_NODES':\n            draft.nodes = action.payload;\n            return;\n\n        case 'REPLACE_EXPANDED':\n            draft.expandedIds = new Set(action.payload);\n            return;\n\n        case 'REPLACE_SELECTED':\n            draft.selectedIds = new Set(action.payload);\n            return;\n\n        case 'REPLACE_STATE':\n            draft.rootNodes = action.payload.rootNodes;\n            draft.overlay = action.payload.overlay;\n            draft.projection = action.payload.projection;\n            draft.selectedIds = action.payload.selectedIds;\n            draft.expandedIds = action.payload.expandedIds;\n            draft.selectionMode = action.payload.selectionMode;\n            return;\n\n        default:\n            console.warn(`Updated tree with action \"${action.type}\" but it has not effect.`);\n            return;\n    }\n});\n\nexport const Tree = memo(\n    ({\n        id,\n        onDrop,\n        onSelect = () => void 0,\n        onExpand,\n        onShrink,\n        children,\n        selectedIds,\n        expandedIds,\n        draggable = false,\n        multiselect = false,\n        dragHandlerPosition = 'left',\n        showDragHandlerOnHoverOnly = true,\n        showContentWhileDragging = false,\n        itemStyle,\n        'data-test-id': dataTestId = 'fondue-tree',\n    }: TreeProps) => {\n        const initialState: TreeState = useMemo(\n            () => ({\n                selectionMode: 'single',\n                selectedIds: new Set(selectedIds ?? []),\n                expandedIds: new Set(expandedIds ?? []),\n                rootNodes: [],\n                expandedNodes: [],\n                nodes: [],\n                nodesReady: false,\n                projection: null,\n            }),\n            [expandedIds, selectedIds],\n        );\n\n        const [treeState, updateTreeState] = useReducer(reducer, initialState);\n        const [, startTransition] = useTransition();\n\n        const [offset, setOffset] = useState<Nullable<number>>(null);\n        const [overId, setOverId] = useState<Nullable<string>>(null);\n        const [activeId, setActiveId] = useState<Nullable<string>>(null);\n        const [currentPosition, setCurrentPosition] =\n            useState<Nullable<{ overId: string; parentId: Nullable<string> }>>(null);\n\n        useEffect(() => {\n            const keyDownHandler = (event: globalThis.KeyboardEvent) => {\n                if (shouldUpdateTreeState(event, multiselect)) {\n                    updateTreeState({\n                        type: 'SET_SELECTION_MODE',\n                        payload: { selectionMode: 'multiselect' },\n                    });\n                }\n            };\n\n            const keyUpHandler = (event: globalThis.KeyboardEvent) => {\n                if (shouldUpdateTreeState(event, multiselect)) {\n                    updateTreeState({\n                        type: 'SET_SELECTION_MODE',\n                        payload: { selectionMode: 'single' },\n                    });\n                }\n            };\n\n            if (multiselect) {\n                window.addEventListener('keydown', keyDownHandler);\n                window.addEventListener('keyup', keyUpHandler);\n            }\n\n            return () => {\n                window.removeEventListener('keydown', keyDownHandler);\n                window.removeEventListener('keyup', keyUpHandler);\n            };\n        }, [multiselect]);\n\n        const registerOverlay = useCallback((overlay: Overlay) => {\n            updateTreeState({ type: 'REGISTER_OVERLAY_ITEM', payload: overlay });\n        }, []);\n\n        const registerNodeChildren = useCallback((payload: RegisterNodeChildrenPayload) => {\n            updateTreeState({ type: 'REGISTER_NODE_CHILDREN', payload });\n        }, []);\n\n        const unregisterNodeChildren = useCallback((payload: string) => {\n            updateTreeState({ type: 'UNREGISTER_NODE_CHILDREN', payload });\n        }, []);\n\n        const handleSelect = useCallback(\n            (id: string) => {\n                onSelect(id);\n            },\n            [onSelect],\n        );\n\n        const handleExpand = useCallback(\n            (id: string) => {\n                if (onExpand) {\n                    return onExpand(id);\n                }\n\n                updateTreeState({\n                    type: 'EXPAND_NODE',\n                    payload: id,\n                });\n            },\n            [onExpand],\n        );\n\n        const handleShrink = useCallback(\n            (id: string) => {\n                if (onShrink) {\n                    return onShrink(id);\n                }\n\n                updateTreeState({\n                    type: 'SHRINK_NODE',\n                    payload: id,\n                });\n            },\n            [onShrink],\n        );\n\n        const handleDragEnd = (event: DragEndEvent) => {\n            resetState();\n\n            const { over, active } = event;\n\n            if (!over?.id || !active?.id || !treeState.projection?.parentId) {\n                return;\n            }\n\n            const activeNode = treeState.nodes.find((node) => node.props.id === active.id);\n            const contentComponent = activeNode?.props?.contentComponent;\n\n            onDrop?.({\n                id: active.id.toString(),\n                parentId: treeState.projection.parentId,\n                sort: treeState.projection.position,\n                contentComponent,\n            });\n        };\n\n        const handleDragStart = ({ active: { id: activeId, data } }: TreeDragStartEvent) => {\n            setActiveId(activeId);\n            setOverId(activeId);\n\n            if (activeId && data.current) {\n                setCurrentPosition({\n                    parentId: data.current.parentId,\n                    overId: activeId,\n                });\n            }\n\n            document.body.style.setProperty('cursor', 'grabbing');\n        };\n\n        const handleDragOver = ({ over }: TreeDragOverEvent) => {\n            setOverId(over?.id ?? null);\n        };\n\n        const handleDragMove = ({ delta }: DragMoveEvent) => {\n            setOffset(delta.x);\n        };\n\n        const handleDragCancel = () => {\n            resetState();\n        };\n\n        const resetState = () => {\n            setOverId(null);\n            setActiveId(null);\n            setOffset(0);\n            setCurrentPosition(null);\n\n            document.body.style.setProperty('cursor', 'default');\n        };\n\n        const handleKeyDown = useCallback(\n            (event: KeyboardEvent<HTMLUListElement>) => {\n                return handleKeyDownEvent(\n                    event,\n                    treeState.expandedIds,\n                    treeState.nodes,\n                    handleSelect,\n                    handleShrink,\n                    handleExpand,\n                );\n            },\n            [handleExpand, handleShrink, handleSelect, treeState.expandedIds, treeState.nodes],\n        );\n\n        const sensorContext: SensorContext = useRef({\n            nodes: treeState.nodes,\n            offset: offset ?? 0,\n        });\n\n        const [coordinateGetter] = useState(() => sortableTreeKeyboardCoordinates(sensorContext));\n        const activationConstraint = sensorsActivationConstraint(dragHandlerPosition);\n\n        const sensors = useSensors(\n            useSensor(PointerSensor, { activationConstraint }),\n            useSensor(KeyboardSensor, { coordinateGetter }),\n        );\n\n        const announcements: TreeAnnouncements = useMemo(() => {\n            return getAnnouncements(treeState, currentPosition, setCurrentPosition);\n        }, [currentPosition, treeState]);\n\n        useDeepCompareEffect(() => {\n            if (!children) {\n                return;\n            }\n\n            updateTreeState({\n                type: 'REGISTER_ROOT_NODES',\n                payload: recursivelyRemoveFragmentsAndEnrichChildren(children, { parentId: ROOT_ID, level: 0 }),\n            });\n        }, [children]);\n\n        useDeepCompareEffect(() => {\n            if (treeState.rootNodes.length === 0) {\n                return;\n            }\n\n            startTransition(() => {\n                const nodesToRender = getNodesToRender(treeState.rootNodes, treeState.expandedIds);\n\n                updateTreeState({\n                    type: 'REGISTER_NODES',\n                    payload: nodesToRender,\n                });\n            });\n        }, [treeState.rootNodes, treeState.expandedIds]);\n\n        useEffect(() => {\n            updateTreeState({\n                type: 'REPLACE_EXPANDED',\n                payload: expandedIds ?? [],\n            });\n        }, [expandedIds]);\n\n        useEffect(() => {\n            updateTreeState({\n                type: 'REPLACE_SELECTED',\n                payload: selectedIds ?? [],\n            });\n        }, [selectedIds]);\n\n        useDeepCompareEffect(() => {\n            sensorContext.current = {\n                nodes: treeState.nodes,\n                offset: offset ?? 0,\n            };\n        }, [offset, treeState.nodes]);\n\n        useEffect(() => {\n            const projection =\n                activeId && overId\n                    ? getProjection({\n                          nodes: treeState.nodes,\n                          activeId,\n                          overId,\n                          dragOffset: offset ?? 0,\n                      })\n                    : null;\n\n            updateTreeState({\n                type: 'SET_PROJECTION',\n                payload: projection,\n            });\n        }, [activeId, offset, overId, treeState.nodes]);\n\n        const getPropToUse = (\n            nodeProp: TreeItemProps['dragHandlerPosition' | 'showContentWhileDragging' | 'showDragHandlerOnHoverOnly'],\n            treeProp: TreeProps['dragHandlerPosition' | 'showContentWhileDragging' | 'showDragHandlerOnHoverOnly'],\n        ) => nodeProp || treeProp;\n\n        const { nodes, items } = useMemo(() => {\n            const treeItemStyle = {\n                spacingY: 'none',\n                contentHight: 'single-line',\n                shadow: 'none',\n                borderRadius: 'small',\n                borderWidth: 'none',\n                borderStyle: 'none',\n                activeColorStyle: 'neutral',\n                ...itemStyle,\n            } as TreeItemStyling;\n\n            return {\n                items: treeState.nodes.map((node) => node.props.id),\n                nodes: treeState.nodes.map((node) =>\n                    cloneElement(node, {\n                        treeDraggable: draggable,\n                        dragHandlerPosition: getPropToUse(\n                            node.props.dragHandlerPosition,\n                            dragHandlerPosition,\n                        ) as TreeProps['dragHandlerPosition'],\n                        showDragHandlerOnHoverOnly: getPropToUse(\n                            node.props.showDragHandlerOnHoverOnly,\n                            showDragHandlerOnHoverOnly,\n                        ) as TreeProps['showDragHandlerOnHoverOnly'],\n                        showContentWhileDragging: getPropToUse(\n                            node.props.showContentWhileDragging,\n                            showContentWhileDragging,\n                        ) as TreeProps['showContentWhileDragging'],\n                        itemStyle: { ...treeItemStyle, ...node.props.itemStyle },\n                        registerOverlay,\n                        onExpand: handleExpand,\n                        onShrink: handleShrink,\n                        onSelect: handleSelect,\n                        registerNodeChildren,\n                        unregisterNodeChildren,\n                    }),\n                ),\n            };\n        }, [\n            treeState.nodes,\n            draggable,\n            dragHandlerPosition,\n            showDragHandlerOnHoverOnly,\n            showContentWhileDragging,\n            itemStyle,\n            registerOverlay,\n            handleExpand,\n            handleShrink,\n            handleSelect,\n            registerNodeChildren,\n            unregisterNodeChildren,\n        ]);\n\n        const contextValue: TreeContextProps = useMemo(\n            () => ({\n                treeState,\n                onSelect: handleSelect,\n                onExpand: handleExpand,\n                onShrink: handleShrink,\n            }),\n            [treeState, handleSelect, handleExpand, handleShrink],\n        );\n\n        return (\n            <TreeContext.Provider value={contextValue}>\n                <ul\n                    id={id}\n                    role=\"tree\"\n                    data-test-id={dataTestId}\n                    onKeyDown={handleKeyDown}\n                    aria-multiselectable={treeState.selectionMode === 'multiselect'}\n                    className=\"tw-p-0 tw-m-0 tw-font-sans tw-font-normal tw-list-none tw-text-left tw-text-sm tw-select-none\"\n                >\n                    <DndContext\n                        sensors={sensors}\n                        measuring={measuring}\n                        onDragEnd={handleDragEnd}\n                        onDragOver={handleDragOver}\n                        onDragMove={handleDragMove}\n                        onDragStart={handleDragStart}\n                        onDragCancel={handleDragCancel}\n                        accessibility={{\n                            announcements,\n                            container: document.getElementById(id)?.parentElement ?? document.body,\n                        }}\n                        collisionDetection={closestCorners}\n                    >\n                        <SortableContext items={items} strategy={verticalListSortingStrategy}>\n                            {nodes}\n                        </SortableContext>\n\n                        {createPortal(\n                            <DragOverlay\n                                zIndex={1500}\n                                wrapperElement=\"ul\"\n                                dropAnimation={null}\n                                modifiers={[restrictToWindowEdges]}\n                            >\n                                {treeState.overlay && (\n                                    <TreeItemOverlay\n                                        {...treeState.overlay}\n                                        isSelected={treeState.selectedIds.has(treeState.overlay.id)}\n                                    />\n                                )}\n                            </DragOverlay>,\n                            document.body,\n                        )}\n                    </DndContext>\n                </ul>\n            </TreeContext.Provider>\n        );\n    },\n);\n\nTree.displayName = 'FondueTree';\n"],"names":["measuring","MeasuringStrategy","enableMapSet","reducer","produce","draft","action","newExpanded","isEqual","getCurrentChildrenForNewNodesIfExpanded","parentId","children","findIndexById","currentChildrenIds","getNodeChildrenIds","newChildrenIds","node","currentNodesChanged","newChildren","updateNodeWithNewChildren","nodeIds","getReactNodeIdsInFlatArray","removeReactNodesFromFlatArray","Tree","memo","id","onDrop","onSelect","onExpand","onShrink","selectedIds","expandedIds","draggable","multiselect","dragHandlerPosition","showDragHandlerOnHoverOnly","showContentWhileDragging","itemStyle","dataTestId","initialState","useMemo","treeState","updateTreeState","useReducer","startTransition","useTransition","offset","setOffset","useState","overId","setOverId","activeId","setActiveId","currentPosition","setCurrentPosition","useEffect","keyDownHandler","event","shouldUpdateTreeState","keyUpHandler","registerOverlay","useCallback","overlay","registerNodeChildren","payload","unregisterNodeChildren","handleSelect","handleExpand","handleShrink","handleDragEnd","resetState","over","active","_a","activeNode","contentComponent","_b","handleDragStart","data","handleDragOver","handleDragMove","delta","handleDragCancel","handleKeyDown","handleKeyDownEvent","sensorContext","useRef","coordinateGetter","sortableTreeKeyboardCoordinates","activationConstraint","sensorsActivationConstraint","sensors","useSensors","useSensor","PointerSensor","KeyboardSensor","announcements","getAnnouncements","useDeepCompareEffect","recursivelyRemoveFragmentsAndEnrichChildren","ROOT_ID","nodesToRender","getNodesToRender","projection","getProjection","getPropToUse","nodeProp","treeProp","nodes","items","treeItemStyle","cloneElement","contextValue","jsx","TreeContext","jsxs","DndContext","closestCorners","SortableContext","verticalListSortingStrategy","createPortal","DragOverlay","restrictToWindowEdges","TreeItemOverlay"],"mappings":"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"}