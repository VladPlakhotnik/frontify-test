import { jsx as g, jsxs as ye } from "react/jsx-runtime";
import { memo as me, useMemo as w, useReducer as Ie, useTransition as Ne, useState as R, useEffect as C, useCallback as p, useRef as Se, cloneElement as ge } from "react";
import { SortableContext as Re, verticalListSortingStrategy as De } from "@dnd-kit/sortable";
import { restrictToWindowEdges as we } from "@dnd-kit/modifiers";
import { enableMapSet as Ce, produce as he } from "immer";
import { createPortal as Te } from "react-dom";
import Y from "../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.es.js";
import { MeasuringStrategy as Oe, useSensors as fe, useSensor as B, PointerSensor as _e, KeyboardSensor as ve, DndContext as xe, closestCorners as Le, DragOverlay as Pe } from "@dnd-kit/core";
import { TreeContext as Ae } from "./TreeContext.es.js";
import { getReactNodeIdsInFlatArray as be, removeReactNodesFromFlatArray as Me, getNodesToRender as je } from "./helpers/nodes.es.js";
import { findIndexById as Ge, getNodeChildrenIds as He, currentNodesChanged as ke, getCurrentChildrenForNewNodesIfExpanded as J, updateNodeWithNewChildren as Ke, shouldUpdateTreeState as $ } from "./helpers/reducer.es.js";
import { handleKeyDownEvent as Fe } from "./helpers/treeHandleKeyDown.es.js";
import { sortableTreeKeyboardCoordinates as Ue } from "./utils/keyboardCoordinates.es.js";
import { getAnnouncements as We } from "./helpers/getMovementAnnouncements.es.js";
import { TreeItemOverlay as Xe } from "./TreeItem/TreeItemOverlay.es.js";
import { sensorsActivationConstraint as Ve } from "./helpers/sensorsActivationConstraint.es.js";
import { recursivelyRemoveFragmentsAndEnrichChildren as Ye } from "./utils/removeFragmentsAndEnrichChildren.es.js";
import { useDeepCompareEffect as L } from "./utils/useDeepCompareEffect.es.js";
import { getProjection as Be } from "./helpers/projection.es.js";
import { ROOT_ID as Je } from "./helpers/constants.es.js";
const $e = {
  droppable: {
    strategy: Oe.Always
  }
};
Ce();
const qe = he((o, n) => {
  switch (n.type) {
    case "EXPAND_NODE":
      o.expandedIds = new Set(o.expandedIds).add(n.payload);
      return;
    case "SHRINK_NODE":
      const N = new Set(o.expandedIds);
      N.delete(n.payload), o.expandedIds = N;
      return;
    case "SET_SELECTION_MODE":
      o.selectionMode = n.payload.selectionMode;
      return;
    case "SET_PROJECTION":
      Y(o.projection, n.payload) || (o.projection = n.payload);
      return;
    case "REGISTER_OVERLAY_ITEM":
      o.overlay = n.payload;
      return;
    case "REGISTER_ROOT_NODES":
      o.rootNodes = J(
        o.rootNodes,
        o.expandedIds,
        n.payload
      );
      return;
    case "REGISTER_NODE_CHILDREN":
      const { id: a, children: l } = n.payload;
      if (Ge(o.rootNodes, a) === -1) {
        console.warn(`Parent element with ID "${a}" not found when registering children.`);
        return;
      }
      const c = He(o.rootNodes, a), E = l.map((u) => u.props.id);
      if (!Y(c, E) || ke(c, o.rootNodes, l)) {
        const u = J(
          o.rootNodes,
          o.expandedIds,
          l
        );
        o.rootNodes = Ke(o.rootNodes, a, u);
      }
      return;
    case "UNREGISTER_NODE_CHILDREN":
      const i = be(o.rootNodes, n.payload);
      i.length > 0 && (o.rootNodes = Me(o.rootNodes, i));
      return;
    case "REGISTER_NODES":
      o.nodes = n.payload;
      return;
    case "REPLACE_EXPANDED":
      o.expandedIds = new Set(n.payload);
      return;
    case "REPLACE_SELECTED":
      o.selectedIds = new Set(n.payload);
      return;
    case "REPLACE_STATE":
      o.rootNodes = n.payload.rootNodes, o.overlay = n.payload.overlay, o.projection = n.payload.projection, o.selectedIds = n.payload.selectedIds, o.expandedIds = n.payload.expandedIds, o.selectionMode = n.payload.selectionMode;
      return;
    default:
      console.warn(`Updated tree with action "${n.type}" but it has not effect.`);
      return;
  }
}), ze = me(
  ({
    id: o,
    onDrop: n,
    onSelect: N = () => {
    },
    onExpand: a,
    onShrink: l,
    children: c,
    selectedIds: E,
    expandedIds: i,
    draggable: u = !1,
    multiselect: D = !1,
    dragHandlerPosition: h = "left",
    showDragHandlerOnHoverOnly: P = !0,
    showContentWhileDragging: A = !1,
    itemStyle: b,
    "data-test-id": q = "fondue-tree"
  }) => {
    var W;
    const z = w(
      () => ({
        selectionMode: "single",
        selectedIds: new Set(E ?? []),
        expandedIds: new Set(i ?? []),
        rootNodes: [],
        expandedNodes: [],
        nodes: [],
        nodesReady: !1,
        projection: null
      }),
      [i, E]
    ), [t, s] = Ie(qe, z), [, Q] = Ne(), [S, M] = R(null), [T, O] = R(null), [f, j] = R(null), [G, _] = R(null);
    C(() => {
      const e = (d) => {
        $(d, D) && s({
          type: "SET_SELECTION_MODE",
          payload: { selectionMode: "multiselect" }
        });
      }, r = (d) => {
        $(d, D) && s({
          type: "SET_SELECTION_MODE",
          payload: { selectionMode: "single" }
        });
      };
      return D && (window.addEventListener("keydown", e), window.addEventListener("keyup", r)), () => {
        window.removeEventListener("keydown", e), window.removeEventListener("keyup", r);
      };
    }, [D]);
    const H = p((e) => {
      s({ type: "REGISTER_OVERLAY_ITEM", payload: e });
    }, []), k = p((e) => {
      s({ type: "REGISTER_NODE_CHILDREN", payload: e });
    }, []), K = p((e) => {
      s({ type: "UNREGISTER_NODE_CHILDREN", payload: e });
    }, []), y = p(
      (e) => {
        N(e);
      },
      [N]
    ), m = p(
      (e) => {
        if (a)
          return a(e);
        s({
          type: "EXPAND_NODE",
          payload: e
        });
      },
      [a]
    ), I = p(
      (e) => {
        if (l)
          return l(e);
        s({
          type: "SHRINK_NODE",
          payload: e
        });
      },
      [l]
    ), Z = (e) => {
      var X, V;
      F();
      const { over: r, active: d } = e;
      if (!(r != null && r.id) || !(d != null && d.id) || !((X = t.projection) != null && X.parentId))
        return;
      const x = t.nodes.find((ue) => ue.props.id === d.id), Ee = (V = x == null ? void 0 : x.props) == null ? void 0 : V.contentComponent;
      n == null || n({
        id: d.id.toString(),
        parentId: t.projection.parentId,
        sort: t.projection.position,
        contentComponent: Ee
      });
    }, ee = ({ active: { id: e, data: r } }) => {
      j(e), O(e), e && r.current && _({
        parentId: r.current.parentId,
        overId: e
      }), document.body.style.setProperty("cursor", "grabbing");
    }, oe = ({ over: e }) => {
      O((e == null ? void 0 : e.id) ?? null);
    }, te = ({ delta: e }) => {
      M(e.x);
    }, ne = () => {
      F();
    }, F = () => {
      O(null), j(null), M(0), _(null), document.body.style.setProperty("cursor", "default");
    }, re = p(
      (e) => Fe(
        e,
        t.expandedIds,
        t.nodes,
        y,
        I,
        m
      ),
      [m, I, y, t.expandedIds, t.nodes]
    ), U = Se({
      nodes: t.nodes,
      offset: S ?? 0
    }), [se] = R(() => Ue(U)), de = Ve(h), ae = fe(
      B(_e, { activationConstraint: de }),
      B(ve, { coordinateGetter: se })
    ), le = w(() => We(t, G, _), [G, t]);
    L(() => {
      c && s({
        type: "REGISTER_ROOT_NODES",
        payload: Ye(c, { parentId: Je, level: 0 })
      });
    }, [c]), L(() => {
      t.rootNodes.length !== 0 && Q(() => {
        const e = je(t.rootNodes, t.expandedIds);
        s({
          type: "REGISTER_NODES",
          payload: e
        });
      });
    }, [t.rootNodes, t.expandedIds]), C(() => {
      s({
        type: "REPLACE_EXPANDED",
        payload: i ?? []
      });
    }, [i]), C(() => {
      s({
        type: "REPLACE_SELECTED",
        payload: E ?? []
      });
    }, [E]), L(() => {
      U.current = {
        nodes: t.nodes,
        offset: S ?? 0
      };
    }, [S, t.nodes]), C(() => {
      const e = f && T ? Be({
        nodes: t.nodes,
        activeId: f,
        overId: T,
        dragOffset: S ?? 0
      }) : null;
      s({
        type: "SET_PROJECTION",
        payload: e
      });
    }, [f, S, T, t.nodes]);
    const v = (e, r) => e || r, { nodes: ie, items: pe } = w(() => {
      const e = {
        spacingY: "none",
        contentHight: "single-line",
        shadow: "none",
        borderRadius: "small",
        borderWidth: "none",
        borderStyle: "none",
        activeColorStyle: "neutral",
        ...b
      };
      return {
        items: t.nodes.map((r) => r.props.id),
        nodes: t.nodes.map(
          (r) => ge(r, {
            treeDraggable: u,
            dragHandlerPosition: v(
              r.props.dragHandlerPosition,
              h
            ),
            showDragHandlerOnHoverOnly: v(
              r.props.showDragHandlerOnHoverOnly,
              P
            ),
            showContentWhileDragging: v(
              r.props.showContentWhileDragging,
              A
            ),
            itemStyle: { ...e, ...r.props.itemStyle },
            registerOverlay: H,
            onExpand: m,
            onShrink: I,
            onSelect: y,
            registerNodeChildren: k,
            unregisterNodeChildren: K
          })
        )
      };
    }, [
      t.nodes,
      u,
      h,
      P,
      A,
      b,
      H,
      m,
      I,
      y,
      k,
      K
    ]), ce = w(
      () => ({
        treeState: t,
        onSelect: y,
        onExpand: m,
        onShrink: I
      }),
      [t, y, m, I]
    );
    return /* @__PURE__ */ g(Ae.Provider, { value: ce, children: /* @__PURE__ */ g(
      "ul",
      {
        id: o,
        role: "tree",
        "data-test-id": q,
        onKeyDown: re,
        "aria-multiselectable": t.selectionMode === "multiselect",
        className: "tw-p-0 tw-m-0 tw-font-sans tw-font-normal tw-list-none tw-text-left tw-text-sm tw-select-none",
        children: /* @__PURE__ */ ye(
          xe,
          {
            sensors: ae,
            measuring: $e,
            onDragEnd: Z,
            onDragOver: oe,
            onDragMove: te,
            onDragStart: ee,
            onDragCancel: ne,
            accessibility: {
              announcements: le,
              container: ((W = document.getElementById(o)) == null ? void 0 : W.parentElement) ?? document.body
            },
            collisionDetection: Le,
            children: [
              /* @__PURE__ */ g(Re, { items: pe, strategy: De, children: ie }),
              Te(
                /* @__PURE__ */ g(
                  Pe,
                  {
                    zIndex: 1500,
                    wrapperElement: "ul",
                    dropAnimation: null,
                    modifiers: [we],
                    children: t.overlay && /* @__PURE__ */ g(
                      Xe,
                      {
                        ...t.overlay,
                        isSelected: t.selectedIds.has(t.overlay.id)
                      }
                    )
                  }
                ),
                document.body
              )
            ]
          }
        )
      }
    ) });
  }
);
ze.displayName = "FondueTree";
export {
  ze as Tree
};
//# sourceMappingURL=Tree.es.js.map
