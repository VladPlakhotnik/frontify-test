#!/usr/bin/env node
import { cac as G } from "cac";
import g from "prompts";
import { exit as k } from "node:process";
import { join as c, resolve as h } from "node:path";
import { URL as W, fileURLToPath as j } from "node:url";
import u from "picocolors";
import { readFileSync as E, writeFileSync as X, readdirSync as P, mkdirSync as Q, statSync as Z, copyFileSync as ee } from "node:fs";
import w from "@vitejs/plugin-react";
import { build as D, createServer as O } from "vite";
import { viteExternalsPlugin as R } from "vite-plugin-externals";
import { createHash as te } from "crypto";
import re from "conf";
import ne from "glob-to-regexp";
import "node:crypto";
import oe from "node-fetch";
import { exec as se } from "node:child_process";
import "archiver";
import ae from "fast-glob";
import _ from "open";
import ie from "fastify";
import ce from "@fastify/cors";
const x = () => {
  const t = /* @__PURE__ */ new Date();
  return `${String(t.getHours()).padStart(2, "0")}:${String(t.getMinutes()).padStart(2, "0")}:${String(
    t.getSeconds()
  ).padStart(2, "0")}`;
};
class o {
  static defaultInfo(...e) {
    console.log(o.spacer(10), ...e);
  }
  static info(...e) {
    console.log(`[${x()}] ${e.join(" ")}`);
  }
  static success(...e) {
    console.log(`[${x()}] ${u.green(e.join(" "))}`);
  }
  static error(...e) {
    console.error(u.red(`[${x()}] ${e.join(" ")}`));
  }
  static spacer(e = 1) {
    return Array(e + 1).join(" ");
  }
}
class le extends Error {
  constructor(e) {
    super(), this.name = "ParseJsonError", o.error(`The file at "${e}" could not be parsed.`);
  }
}
class v extends Error {
  constructor(e) {
    super(), this.name = "FileNotFoundError", o.error(`The file at "${e}" was not found.`);
  }
}
const y = (t) => {
  try {
    const e = E(t, "utf8"), r = JSON.parse(e);
    return new Proxy(r, {
      set: (s, n, a) => {
        s[n] = a;
        const i = JSON.stringify(s, null, "	");
        return X(t, i), !0;
      }
    });
  } catch (e) {
    throw e instanceof SyntaxError ? new le(t) : e.code === "ENOENT" ? new v(t) : new Error(e);
  }
}, N = (t) => y(c(t, "package.json")).dependencies["@frontify/app-bridge"], B = async ({ projectPath: t, entryFile: e, outputName: r }) => {
  const s = N(t);
  return D({
    plugins: [
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      w(),
      R({
        react: "React",
        "react-dom": "ReactDOM"
      })
    ],
    define: {
      "process.env.NODE_ENV": JSON.stringify("production")
    },
    root: t,
    build: {
      lib: {
        name: r,
        entry: e,
        formats: ["iife"],
        fileName: () => "index.js"
      },
      rollupOptions: {
        external: ["react", "react-dom"],
        output: {
          globals: {
            react: "React",
            "react-dom": "ReactDOM"
          },
          footer: `
                        window.${r} = ${r}; 
                        window.${r}.dependencies = window.${r}.packages || {};
                        window.${r}.dependencies['@frontify/app-bridge'] = '${s}';
                    `
        }
      }
    }
  });
}, pe = async ({ outputName: t, projectPath: e = "" }) => {
  const r = (n) => te("sha256").update(n).digest("hex"), s = {
    name: "html-hash",
    enforce: "post",
    transformIndexHtml(n, { bundle: a }) {
      const i = `${t}.${r(a["index.css"].source)}.css`, l = `${t}.${r(a["index.js"].code)}.js`;
      return n = n.replace("index.css", i).replace("index.js", l), n;
    },
    generateBundle(n, a) {
      a["index.html"].fileName = `${t}.${r(a["index.html"].source)}.html`, a["index.css"].fileName = `${t}.${r(a["index.css"].source)}.css`, a["index.js"].fileName = `${t}.${r(a["index.js"].code)}.js`;
    }
  };
  return D({
    plugins: [
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      w(),
      s
    ],
    root: e,
    build: {
      rollupOptions: {
        output: {
          assetFileNames: () => "[name][extname]",
          chunkFileNames: "[name].js",
          entryFileNames: "[name].js"
        }
      }
    }
  });
};
class m {
  static set(e, r) {
    this.conf.set(e, r);
  }
  static get(e) {
    return this.conf.get(e, void 0);
  }
  static delete(e) {
    return this.conf.delete(e);
  }
}
m.conf = new re({
  projectName: "frontify-cli"
});
const de = (t) => {
  try {
    return P(t).length === 0;
  } catch {
    return !0;
  }
}, S = (t, e, r) => {
  Q(e, { recursive: !0 });
  const s = r == null ? void 0 : r.exclude.map((n) => ne(n));
  for (const n of P(t)) {
    if (s !== void 0 && s.some((l) => l.test(n)))
      continue;
    const a = h(t, n), i = h(e, n);
    fe(a, i);
  }
}, fe = (t, e) => {
  Z(t).isDirectory() ? S(t, e) : ee(t, e);
}, ue = (t) => {
  try {
    return E(t, "utf-8");
  } catch {
    throw new v(t);
  }
}, me = (t) => {
  try {
    return E(t, "base64");
  } catch {
    throw new v(t);
  }
}, he = (t) => {
  try {
    return ue(t).split(/\r?\n/).filter((r) => r !== "");
  } catch {
    throw new v(t);
  }
};
class ye extends Error {
  constructor(e, r) {
    super(`Status code ${e}`), this.code = 0, this.name = "HttpClientError", this.code = e, this.responseBody = r;
  }
}
class T {
  constructor(e) {
    this.baseUrl = e.replace(/^https?:\/\//, "");
  }
  async fetchExtended({ method: e, url: r, body: s, options: n }) {
    const a = await oe(this.getAbsoluteUrl(r), {
      method: e,
      ...s && {
        body: JSON.stringify(s)
      },
      ...n,
      headers: { "Content-Type": "application/json", ...n == null ? void 0 : n.headers }
    });
    if (a.status === 200)
      switch (a.headers.get("Content-Type")) {
        case "application/json":
          const l = await a.json();
          return l || void 0;
        default:
          const d = await a.text();
          return d || void 0;
      }
    else {
      const i = await a.json();
      throw new ye(a.status, i);
    }
  }
  get(e, r) {
    return this.fetchExtended({ url: e, method: "GET", options: r });
  }
  post(e, r, s) {
    return this.fetchExtended({ url: e, method: "POST", body: r, options: s });
  }
  put(e, r, s) {
    return this.fetchExtended({ url: e, method: "PUT", body: r, options: s });
  }
  delete(e, r) {
    return this.fetchExtended({ url: e, method: "DELETE", options: r });
  }
  getAbsoluteUrl(e) {
    return `https://${this.baseUrl}${e}`;
  }
}
const A = (t) => {
  const e = h(t, "package.json"), r = y(e);
  r.name = t;
}, I = (t) => t ? /^[_a-z-]+$/.test(t) ? de(t) ? !0 : `The directory ./${t} already exist.` : 'The project name needs to be "a-z" separated by "-" or "_".' : "The content block name can not be empty.";
class ge extends Error {
  constructor(e) {
    super(), this.name = "CommandExecutionError", o.error(`The command execution failed: ${e}`);
  }
}
const U = (t, e = {}) => new Promise((r, s) => {
  se(t, e, (n, a) => n ? s(new ge(n + a)) : r(a));
});
class we extends Error {
  constructor(e) {
    super(), this.name = "InvalidInstanceUrlError", e ? o.error(`The given URL "${e}" is invalid.`) : o.error("No instance URL was given.");
  }
}
const L = (t) => {
  try {
    const e = t.replace(/^https?:\/\//, "");
    return new W(`https://${e}`).hostname;
  } catch {
    throw new we(t);
  }
}, J = async (t) => {
  const e = new T(t), r = m.get("tokens.access_token");
  try {
    return (await e.post(
      "/graphql",
      { query: "{ currentUser { email name } }" },
      { headers: { Authorization: `Bearer ${r}` } }
    )).data.currentUser;
  } catch {
    o.error(`You are not logged in, you can use the command ${u.bold("frontify-cli login")}.`);
    return;
  }
}, ve = "content-block-", V = (t, e = "tailwind") => {
  o.info("Creating the content block...");
  const r = u.blue(`./${t}`);
  o.info(`Scaffolding content block in ${r}...`);
  const s = h(j(import.meta.url), `../../templates/${ve}${e}`);
  S(s, t, { exclude: ["node_modules"] }), A(t), o.defaultInfo(`
${o.spacer(11)}You can now access the project and install dependencies.`);
  const n = u.blue(`./${t}`);
  o.defaultInfo(`${o.spacer(4)}cd ${n}`), o.defaultInfo(`${o.spacer(4)}npm i`), o.defaultInfo(`${o.spacer(4)}npm run serve`), o.defaultInfo(`
${o.spacer(11)}Happy hacking!`);
}, $e = (t, e, r) => {
  o.info(`Creating the ${r}...`);
  const s = u.blue(`./${t}`);
  o.info(`Scaffolding App in ${s}...`);
  const n = h(j(import.meta.url), `../../templates/${r}-${e}`);
  S(n, t, { exclude: ["node_modules"] }), A(t), o.defaultInfo(`
${o.spacer(11)}You can now access the project and install dependencies.`);
  const a = u.blue(`./${t}`);
  o.defaultInfo(`${o.spacer(4)}cd ${a}`), o.defaultInfo(`${o.spacer(4)}npm i`), o.defaultInfo(`${o.spacer(4)}npm run serve`), o.defaultInfo(`
${o.spacer(11)}Happy hacking!`);
}, F = async (t, e) => {
  const r = await ae(c(t, "**"), { ignore: e, dot: !0 });
  return r.map((n) => n.replace(`${t}/`, "")).reduce((n, a, i) => (n[`/${a}`] = me(r[i]), n), {});
}, xe = ["**/*.*.map"], ke = [".git", "node_modules", "dist", ".vscode", ".idea", "README.md", ".DS_Store"], b = async (t, e, { dryRun: r = !1, noVerify: s = !1, openInBrowser: n = !1 }, a) => {
  try {
    let i;
    const l = m.get("instanceUrl");
    if (l || (o.error(`You are not logged in, you can use the command ${u.bold("frontify-cli login")}.`), process.exit(-1)), r || (i = await J(l), i && o.info(`You are logged in as ${i.name} (${l}).`)), i || r) {
      r && o.info(u.blue("Dry run: enabled"));
      const d = process.cwd(), { appId: $ } = y(c(d, "manifest.json"));
      s || (o.info("Performing type checks..."), await U("npx tsc --noEmit"), o.info("Performing eslint checks..."), await U("npx eslint src"));
      try {
        await a({ projectPath: d, entryFile: t, outputName: $ });
      } catch (f) {
        o.error(f), process.exit(-1);
      }
      const Y = xe.map((f) => c(d, f)), M = [...he(c(d, ".gitignore")).filter(
        (f) => f !== "manifest.json"
      ), ...ke].map(
        (f) => c(d, f)
      ), z = {
        build_files: await F(c(d, e), Y),
        source_files: await F(c(d), M)
      };
      if (r)
        o.success("The command has been executed without any issue."), process.exit(0);
      else {
        o.info("Sending the files to Frontify Marketplace...");
        const f = new T(l), q = m.get("tokens.access_token");
        try {
          await f.put(`/api/marketplace/app/${$}`, z, {
            headers: { Authorization: `Bearer ${q}` }
          }), o.success("The new version has been pushed."), n && (o.info("Opening the Frontify Marketplace page..."), await _(`https://${l}/marketplace/apps/${$}`));
        } catch (K) {
          o.error("An error occured while deploying:", K.responseBody.error), process.exit(-1);
        }
      }
    }
  } catch (i) {
    o.error("The deployment has failed and was aborted due to an error:", i), process.exit(-1);
  }
};
class be {
  constructor(e, r = 5600) {
    this.fastifyServer = ie(), this.instanceUrl = e, this.port = r, this.httpClient = new T(e);
  }
  serveCallbackServer() {
    this.registerPlugins(), this.registerRoutes(), this.fastifyServer.listen({ port: this.port });
  }
  registerRoutes() {
    this.fastifyServer.get("/oauth", async (e, r) => {
      o.info("Access granted, getting access token..."), r.send("You can close this window.");
      const s = await this.getOauthCredentialDetails(e.query.code);
      o.info("Tokens received, storing tokens..."), m.set("tokens", s), m.set("instanceUrl", this.instanceUrl);
      const n = await J(this.instanceUrl);
      n && o.success(`${`Welcome back ${n.name} (${this.instanceUrl})!`}`), process.exit(0);
    });
  }
  registerPlugins() {
    this.fastifyServer.register(ce);
  }
  async storeRandomCodeChallenge() {
    try {
      const e = await this.httpClient.get(
        "/api/oauth/random"
      );
      this.randomChallenge = e.data;
    } catch {
      throw new Error("An error occured while getting the random challenge.");
    }
  }
  getLoginUrl() {
    if (!this.randomChallenge)
      throw new Error("Random challenge needs to be defined");
    const e = [
      "response_type=code",
      "client_id=block-cli",
      "redirect_uri=http://localhost:5600/oauth",
      "scope=basic:read%2Bblocks:read%2Bblocks:write",
      `code_challenge=${this.randomChallenge.sha256}`,
      "code_challenge_method=S256"
    ].join("&");
    return `https://${this.instanceUrl}/api/oauth/authorize?${e}`;
  }
  async getOauthCredentialDetails(e) {
    if (!this.randomChallenge)
      throw new Error("Random challenge needs to be defined");
    try {
      return await this.httpClient.post("/api/oauth/accesstoken", {
        grant_type: "authorization_code",
        client_id: "block-cli",
        redirect_uri: "http://localhost:5600/oauth",
        scope: "basic:read%2Bblocks:read%2Bblocks:write",
        code_verifier: this.randomChallenge.secret,
        code: e
      });
    } catch (r) {
      throw new Error(`An error occured while getting tokens: ${r.message}`);
    }
  }
}
const Ee = async (t, e) => {
  try {
    const r = L(t), s = new be(r, e);
    s.serveCallbackServer(), await s.storeRandomCodeChallenge();
    const n = s.getLoginUrl();
    o.info("Attempting to open OAuth login page..."), o.info(
      `If a browser window doesn't automatically open, please open the following link manually: ${n}`
    ), await _(n);
  } catch {
    o.error("You need to enter a valid Frontify instance URL."), process.exit(-1);
  }
}, Se = () => {
  m.delete("tokens"), o.info("You are now logged out.");
}, Te = "@frontify/frontify-cli", Ce = "Frontify Developers <developers@frontify.com>", Ie = "5.5.0", Ue = {
  "frontify-cli": "dist/index.mjs"
}, Fe = {
  node: ">=16"
}, je = {
  type: "git",
  url: "https://github.com/Frontify/brand-sdk",
  directory: "packages/cli"
}, Pe = [
  "dist",
  "templates"
], De = "module", Oe = {
  build: "vite build",
  format: "prettier --write .",
  lint: "eslint .",
  "lint:fix": "eslint --fix .",
  start: "npm run build && node dist/index.mjs",
  test: "vitest run --silent",
  "test:watch": "vitest",
  "test:coverage": "vitest run --coverage",
  "test:ui": "vitest --ui",
  typecheck: "tsc --noEmit"
}, Re = {
  "@fastify/cors": "^8.3.0",
  "@vitejs/plugin-react": "^4.0.4",
  archiver: "^6.0.0",
  cac: "^6.7.14",
  conf: "^11.0.2",
  "fast-glob": "^3.3.1",
  fastify: "^4.22.2",
  "glob-to-regexp": "^0.4.1",
  "node-fetch": "^3.3.2",
  open: "^9.1.0",
  picocolors: "^1.0.0",
  prompts: "^2.4.2",
  vite: "^4.4.9",
  "vite-plugin-externals": "^0.6.2"
}, _e = {
  "@frontify/eslint-config-typescript": "^0.16.1",
  "@types/glob-to-regexp": "^0.4.1",
  "@types/mock-fs": "^4.13.1",
  "@types/node": "^18.17.12",
  "@types/prompts": "^2.4.4",
  "@types/ws": "8.5.5",
  "@vitest/coverage-v8": "0.34.3",
  "@vitest/ui": "^0.34.3",
  eslint: "^8.48.0",
  "eslint-plugin-notice": "^0.9.10",
  "mock-fs": "^5.2.0",
  nock: "^13.3.3",
  prettier: "^3.0.3",
  "ts-node": "^10.9.1",
  typescript: "^5.2.2",
  vitest: "^0.34.3"
}, C = {
  name: Te,
  author: Ce,
  version: Ie,
  bin: Ue,
  engines: Fe,
  repository: je,
  files: Pe,
  type: De,
  scripts: Oe,
  dependencies: Re,
  devDependencies: _e
};
class Ne {
  constructor(e) {
    this.port = e;
  }
  async serve() {
    try {
      (await (await O({
        root: process.cwd(),
        configFile: !1,
        plugins: [
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          w()
        ],
        define: {
          "process.env.NODE_ENV": JSON.stringify("development")
        },
        base: `http://localhost:${this.port}/`
      })).listen(this.port, !0)).printUrls();
    } catch (e) {
      console.error(e), process.exit(1);
    }
  }
}
class Be {
  constructor(e, r, s) {
    this.entryFilePath = e, this.port = r, this.allowExternal = s;
  }
  async serve() {
    try {
      const e = await O({
        root: process.cwd(),
        plugins: [
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          w(),
          R({
            react: "React",
            "react-dom": "ReactDOM"
          })
        ],
        define: {
          "process.env.NODE_ENV": JSON.stringify("development"),
          "DevCustomBlock.dependencies.appBridge": JSON.stringify(N(process.cwd()))
        },
        base: `http://localhost:${this.port}/`,
        appType: "custom",
        server: {
          port: this.port,
          host: this.allowExternal ? "0.0.0.0" : "localhost",
          cors: !0,
          hmr: {
            port: this.port,
            host: this.allowExternal ? "0.0.0.0" : "localhost",
            protocol: "ws"
          }
        }
      });
      e.middlewares.use("/", (s, n, a) => s.url !== "/" ? a() : (n.writeHead(200), n.end("OK"))), e.middlewares.use("/_entrypoint", (s, n, a) => s.url !== "/" ? a() : (n.setHeader("Content-Type", "application/json"), n.writeHead(200), n.end(
        JSON.stringify({
          url: `http://localhost:${this.port}/${this.entryFilePath}`,
          entryFilePath: this.entryFilePath,
          port: this.port,
          version: C.version
        })
      ))), (await e.listen(this.port, !0)).printUrls();
    } catch (e) {
      console.error(e), process.exit(1);
    }
  }
}
const H = async (t, e, r) => {
  o.info("Starting the development server..."), await new Be(t, e, r).serve();
}, Ae = async (t) => {
  o.info("Starting the development server for Apps..."), await new Ne(t).serve();
}, p = G(C.name.split("/")[1]);
p.command("login [instanceUrl]", "log in to a Frontify instance").option("-i, --instance [instanceUrl]", "[string] url of the Frontify instance").option("-p, --port <port>", "[number] port for the oauth service", {
  default: process.env.PORT || 5600
}).action(async (t, e) => {
  const r = t || e.instance || process.env.INSTANCE_URL;
  r && g.inject([r]);
  const { promptedInstanceUrl: s } = await g([
    {
      type: "text",
      name: "promptedInstanceUrl",
      message: "Enter a Frontify instance URL",
      initial: "instanceName.frontify.com",
      validate: (a) => a.trim() === "" ? "You need to enter a valid URL." : !0
    }
  ]);
  s || k(0);
  const n = L(s);
  await Ee(n, e.port);
});
p.command("logout", "log out of an instance").action(Se);
for (const t of ["block", "theme"])
  p.command(`${t} serve`, `[deprecated: use 'serve' instead] serve the ${t} locally`).alias(`${t} dev`).option("-e, --entryPath, --entry-path <entryPath>", `[string] path to the ${t} entry file`, {
    default: c("src", "index.tsx")
  }).option("--port <port>", "[number] specify port", {
    default: process.env.PORT || 5600
  }).option("--allowExternal, --allow-external", "[boolean] allow external IPs to access the server", {
    default: !1
  }).action(async (e) => {
    await H(e.entryPath, e.port, e.allowExternal);
  });
p.command("serve", "serve the app locally").alias("dev").option("-e, --entryPath, --entry-path <entryPath>", "[string] path to the entry file", {
  default: c("src", "index.ts")
}).option("--port <port>", "[number] specify port", {
  default: process.env.PORT || 5600
}).option("--allowExternal, --allow-external", "[boolean] allow external IPs to access the server", {
  default: !1
}).option("--appType [appType], --app-type", "[string] specify app type. Overrides manifest values").action(async (t) => {
  const e = y(c(process.cwd(), "manifest.json"));
  (t.appType || e.appType) === "platform-app" ? await Ae(t.port) : await H(t.entryPath, t.port, t.allowExternal);
});
for (const t of ["block", "theme"])
  p.command(`${t} deploy`, `[deprecated: use 'deploy' instead] deploy the ${t} to the marketplace`).option("-e, --entryPath <entryPath>", "[string] path to the entry file", { default: c("src", "index.tsx") }).option("-o, --outDir <outDir>", "[string] path to the output directory", { default: "dist" }).option("--dryRun, --dry-run", "[boolean] enable the dry run mode", { default: !1 }).option("--noVerify, --no-verify", "[boolean] disable the linting and typechecking", { default: !1 }).option("--open", "[boolean] open the marketplace app page", { default: !1 }).action(async (e) => {
    await b(
      e.entryPath,
      e.outDir,
      {
        dryRun: e.dryRun,
        noVerify: e.noVerify,
        openInBrowser: e.open
      },
      B
    );
  });
p.command("deploy", "deploy the app to the marketplace").option("-e, --entryPath <entryPath>", "[string] path to the entry file", { default: c("src", "index.ts") }).option("-o, --outDir <outDir>", "[string] path to the output directory", { default: "dist" }).option("--dryRun, --dry-run", "[boolean] enable the dry run mode", { default: !1 }).option("--noVerify, --no-verify", "[boolean] disable the linting and typechecking", { default: !1 }).option("--open", "[boolean] open the marketplace app page", { default: !1 }).option("--appType [appType], --app-type", "[string] specify app type. Overrides manifest values").action(async (t) => {
  const e = y(c(process.cwd(), "manifest.json"));
  (t.appType || e.appType) === "platform-app" ? await b(
    t.entryPath,
    t.outDir,
    {
      dryRun: t.dryRun,
      noVerify: t.noVerify,
      openInBrowser: t.open
    },
    pe
  ) : await b(
    t.entryPath,
    t.outDir,
    {
      dryRun: t.dryRun,
      noVerify: t.noVerify,
      openInBrowser: t.open
    },
    B
  );
});
p.command("create [appName]", "create a new marketplace app").option("-e, --experimental", "set experimental flag").action(async (t, e) => {
  if (e.experimental) {
    const { promptedAppName: r, stylingFramework: s, appType: n } = await g([
      {
        type: "text",
        name: "promptedAppName",
        message: "Enter your app name",
        initial: t || "my-frontify-app",
        validate: (a) => a.trim() === "" ? "You need to enter an app name." : I(a)
      },
      {
        type: "select",
        name: "appType",
        message: "Select the type of your app",
        choices: [
          { title: "App", value: "platform-app" },
          { title: "Block", value: "content-block" }
        ]
      },
      {
        type: "select",
        name: "stylingFramework",
        message: "Choose a styling framework",
        choices: [
          { title: "Tailwind", value: "tailwind" },
          { title: "CSS Modules", value: "css-modules" },
          { title: "None", value: "css" }
        ]
      }
    ]);
    (!r || !s || !n) && k(0), $e(r, s, n);
  } else {
    const { promptedAppName: r, stylingFramework: s } = await g([
      {
        type: "text",
        name: "promptedAppName",
        message: "Enter your app name",
        initial: t || "my-frontify-app",
        validate: (n) => n.trim() === "" ? "You need to enter an app name." : I(n)
      },
      {
        type: "select",
        name: "stylingFramework",
        message: "Choose a styling framework",
        choices: [
          { title: "Tailwind", value: "tailwind" },
          { title: "CSS Modules", value: "css-modules" },
          { title: "None", value: "css" }
        ]
      }
    ]);
    (!r || !s) && k(0), V(r, s);
  }
});
for (const t of ["block", "theme"])
  p.command(
    `${t} create [appName]`,
    `[deprecated: use 'create' instead] create a ${t} app locally`
  ).action((e) => V(e, "css-modules"));
p.help();
p.version(C.version);
const Le = (t) => {
  const e = t.findIndex((r) => r === "block" || r === "theme");
  return e !== -1 && (t[e + 1] === "serve" || t[e + 1] === "deploy" || t[e + 1] === "create") && (t[e] = `${t[e]} ${t[e + 1]}`, t.splice(e + 1, 1)), t;
};
p.parse(Le(process.argv));
//# sourceMappingURL=index.mjs.map
